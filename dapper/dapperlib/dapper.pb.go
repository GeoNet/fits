// Code generated by protoc-gen-go. DO NOT EDIT.
// source: dapper.proto

/*
Package dapperlib is a generated protocol buffer package.

It is generated from these files:
	dapper.proto

It has these top-level messages:
	DataQueryResults
	DataQueryResult
	DataQueryRecord
	KeyMetadataList
	KeyMetadata
	Metadata
	MetadataValue
	Tag
	RelationSpan
	Relation
	PointSpan
	KeyMetadataSnapshotList
	KeyMetadataSnapshot
	DomainMetadataList
	MetadataValuesList
	Timespan
	Point
*/
package dapperlib

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type DataQueryResults struct {
	Results []*DataQueryResult `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
}

func (m *DataQueryResults) Reset()                    { *m = DataQueryResults{} }
func (m *DataQueryResults) String() string            { return proto.CompactTextString(m) }
func (*DataQueryResults) ProtoMessage()               {}
func (*DataQueryResults) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *DataQueryResults) GetResults() []*DataQueryResult {
	if m != nil {
		return m.Results
	}
	return nil
}

type DataQueryResult struct {
	Domain  string             `protobuf:"bytes,1,opt,name=domain" json:"domain,omitempty"`
	Key     string             `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	Field   string             `protobuf:"bytes,3,opt,name=field" json:"field,omitempty"`
	Records []*DataQueryRecord `protobuf:"bytes,4,rep,name=records" json:"records,omitempty"`
}

func (m *DataQueryResult) Reset()                    { *m = DataQueryResult{} }
func (m *DataQueryResult) String() string            { return proto.CompactTextString(m) }
func (*DataQueryResult) ProtoMessage()               {}
func (*DataQueryResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DataQueryResult) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *DataQueryResult) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *DataQueryResult) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *DataQueryResult) GetRecords() []*DataQueryRecord {
	if m != nil {
		return m.Records
	}
	return nil
}

type DataQueryRecord struct {
	// A unix timestamp representing when the value was recorded
	Timestamp int64 `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	// The value of the record (encoded as a string)
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *DataQueryRecord) Reset()                    { *m = DataQueryRecord{} }
func (m *DataQueryRecord) String() string            { return proto.CompactTextString(m) }
func (*DataQueryRecord) ProtoMessage()               {}
func (*DataQueryRecord) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DataQueryRecord) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *DataQueryRecord) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type KeyMetadataList struct {
	Metadata []*KeyMetadata `protobuf:"bytes,1,rep,name=metadata" json:"metadata,omitempty"`
}

func (m *KeyMetadataList) Reset()                    { *m = KeyMetadataList{} }
func (m *KeyMetadataList) String() string            { return proto.CompactTextString(m) }
func (*KeyMetadataList) ProtoMessage()               {}
func (*KeyMetadataList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *KeyMetadataList) GetMetadata() []*KeyMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type KeyMetadata struct {
	// The domain the metadata is associated with
	Domain string `protobuf:"bytes,1,opt,name=domain" json:"domain,omitempty"`
	// The key the metadata is associated with
	Key string `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	// The timespan(s) for which this key exists
	Span []*Timespan `protobuf:"bytes,3,rep,name=span" json:"span,omitempty"`
	// Name/Value pairs of metadata (e.g. 'model: MikroTik')
	Metadata map[string]*Metadata `protobuf:"bytes,4,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// String tags of metadata (e.g. 'LINZ')
	Tags      map[string]*Tag `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Location  []*PointSpan    `protobuf:"bytes,6,rep,name=location" json:"location,omitempty"`
	Relations []*RelationSpan `protobuf:"bytes,7,rep,name=relations" json:"relations,omitempty"`
}

func (m *KeyMetadata) Reset()                    { *m = KeyMetadata{} }
func (m *KeyMetadata) String() string            { return proto.CompactTextString(m) }
func (*KeyMetadata) ProtoMessage()               {}
func (*KeyMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *KeyMetadata) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *KeyMetadata) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyMetadata) GetSpan() []*Timespan {
	if m != nil {
		return m.Span
	}
	return nil
}

func (m *KeyMetadata) GetMetadata() map[string]*Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *KeyMetadata) GetTags() map[string]*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *KeyMetadata) GetLocation() []*PointSpan {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *KeyMetadata) GetRelations() []*RelationSpan {
	if m != nil {
		return m.Relations
	}
	return nil
}

type Metadata struct {
	// The name of the metadata (e.g. 'model')
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The value (and potentially past values)
	Values []*MetadataValue `protobuf:"bytes,2,rep,name=values" json:"values,omitempty"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (m *Metadata) String() string            { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Metadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Metadata) GetValues() []*MetadataValue {
	if m != nil {
		return m.Values
	}
	return nil
}

type MetadataValue struct {
	// The value of the metadata (e.g. 'MikroTik')
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
	// The timespan this value is valid for
	Span *Timespan `protobuf:"bytes,2,opt,name=span" json:"span,omitempty"`
}

func (m *MetadataValue) Reset()                    { *m = MetadataValue{} }
func (m *MetadataValue) String() string            { return proto.CompactTextString(m) }
func (*MetadataValue) ProtoMessage()               {}
func (*MetadataValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *MetadataValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *MetadataValue) GetSpan() *Timespan {
	if m != nil {
		return m.Span
	}
	return nil
}

type Tag struct {
	// The name of the tag (e.g. 'LINZ')
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The timespan this value is valid for
	Span []*Timespan `protobuf:"bytes,2,rep,name=span" json:"span,omitempty"`
}

func (m *Tag) Reset()                    { *m = Tag{} }
func (m *Tag) String() string            { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()               {}
func (*Tag) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Tag) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Tag) GetSpan() []*Timespan {
	if m != nil {
		return m.Span
	}
	return nil
}

type RelationSpan struct {
	// The timespan this value is valid for
	Relation *Relation `protobuf:"bytes,1,opt,name=relation" json:"relation,omitempty"`
	// The timespan this value is valid for
	Span *Timespan `protobuf:"bytes,2,opt,name=span" json:"span,omitempty"`
}

func (m *RelationSpan) Reset()                    { *m = RelationSpan{} }
func (m *RelationSpan) String() string            { return proto.CompactTextString(m) }
func (*RelationSpan) ProtoMessage()               {}
func (*RelationSpan) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *RelationSpan) GetRelation() *Relation {
	if m != nil {
		return m.Relation
	}
	return nil
}

func (m *RelationSpan) GetSpan() *Timespan {
	if m != nil {
		return m.Span
	}
	return nil
}

type Relation struct {
	// The domain the metadata is associated with
	Domain string `protobuf:"bytes,1,opt,name=domain" json:"domain,omitempty"`
	// The key the metadata is associated with
	FromKey string `protobuf:"bytes,2,opt,name=from_key,json=fromKey" json:"from_key,omitempty"`
	// The key the metadata is associated with
	ToKey string `protobuf:"bytes,3,opt,name=to_key,json=toKey" json:"to_key,omitempty"`
}

func (m *Relation) Reset()                    { *m = Relation{} }
func (m *Relation) String() string            { return proto.CompactTextString(m) }
func (*Relation) ProtoMessage()               {}
func (*Relation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Relation) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *Relation) GetFromKey() string {
	if m != nil {
		return m.FromKey
	}
	return ""
}

func (m *Relation) GetToKey() string {
	if m != nil {
		return m.ToKey
	}
	return ""
}

type PointSpan struct {
	// The Lat/Lon of the point
	Location *Point `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// The timespan the value is valid for
	Span *Timespan `protobuf:"bytes,2,opt,name=span" json:"span,omitempty"`
}

func (m *PointSpan) Reset()                    { *m = PointSpan{} }
func (m *PointSpan) String() string            { return proto.CompactTextString(m) }
func (*PointSpan) ProtoMessage()               {}
func (*PointSpan) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *PointSpan) GetLocation() *Point {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *PointSpan) GetSpan() *Timespan {
	if m != nil {
		return m.Span
	}
	return nil
}

type KeyMetadataSnapshotList struct {
	Metadata []*KeyMetadataSnapshot `protobuf:"bytes,1,rep,name=metadata" json:"metadata,omitempty"`
}

func (m *KeyMetadataSnapshotList) Reset()                    { *m = KeyMetadataSnapshotList{} }
func (m *KeyMetadataSnapshotList) String() string            { return proto.CompactTextString(m) }
func (*KeyMetadataSnapshotList) ProtoMessage()               {}
func (*KeyMetadataSnapshotList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *KeyMetadataSnapshotList) GetMetadata() []*KeyMetadataSnapshot {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// A simplified version of KeyMetadata without Timespan components (snapshot of metadata at one moment in time)
type KeyMetadataSnapshot struct {
	// The domain the metadata is associated with
	Domain string `protobuf:"bytes,1,opt,name=domain" json:"domain,omitempty"`
	// The key the metadata is associated with
	Key string `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	// The moment of the metadata snapshot
	Moment int64 `protobuf:"varint,3,opt,name=moment" json:"moment,omitempty"`
	// Name/Value pairs of metadata (e.g. 'model: MikroTik')
	Metadata map[string]string `protobuf:"bytes,4,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// String tags of metadata (e.g. 'LINZ')
	Tags      []string        `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
	Location  *Point          `protobuf:"bytes,6,opt,name=location" json:"location,omitempty"`
	Relations []*RelationSpan `protobuf:"bytes,7,rep,name=relations" json:"relations,omitempty"`
}

func (m *KeyMetadataSnapshot) Reset()                    { *m = KeyMetadataSnapshot{} }
func (m *KeyMetadataSnapshot) String() string            { return proto.CompactTextString(m) }
func (*KeyMetadataSnapshot) ProtoMessage()               {}
func (*KeyMetadataSnapshot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *KeyMetadataSnapshot) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *KeyMetadataSnapshot) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyMetadataSnapshot) GetMoment() int64 {
	if m != nil {
		return m.Moment
	}
	return 0
}

func (m *KeyMetadataSnapshot) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *KeyMetadataSnapshot) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *KeyMetadataSnapshot) GetLocation() *Point {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *KeyMetadataSnapshot) GetRelations() []*RelationSpan {
	if m != nil {
		return m.Relations
	}
	return nil
}

type DomainMetadataList struct {
	// The domain being listed
	Domain string `protobuf:"bytes,1,opt,name=domain" json:"domain,omitempty"`
	// All keys in the domain
	Keys []string `protobuf:"bytes,2,rep,name=keys" json:"keys,omitempty"`
	// All possible metadata fields & values in the domain
	Metadata map[string]*MetadataValuesList `protobuf:"bytes,3,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// All possible tags in the domain
	Tags []string `protobuf:"bytes,4,rep,name=tags" json:"tags,omitempty"`
}

func (m *DomainMetadataList) Reset()                    { *m = DomainMetadataList{} }
func (m *DomainMetadataList) String() string            { return proto.CompactTextString(m) }
func (*DomainMetadataList) ProtoMessage()               {}
func (*DomainMetadataList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *DomainMetadataList) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *DomainMetadataList) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *DomainMetadataList) GetMetadata() map[string]*MetadataValuesList {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *DomainMetadataList) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type MetadataValuesList struct {
	// The metadata field name
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// All potential values for that field
	Values []string `protobuf:"bytes,2,rep,name=values" json:"values,omitempty"`
}

func (m *MetadataValuesList) Reset()                    { *m = MetadataValuesList{} }
func (m *MetadataValuesList) String() string            { return proto.CompactTextString(m) }
func (*MetadataValuesList) ProtoMessage()               {}
func (*MetadataValuesList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *MetadataValuesList) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetadataValuesList) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

type Timespan struct {
	Start int64 `protobuf:"varint,1,opt,name=start" json:"start,omitempty"`
	End   int64 `protobuf:"varint,2,opt,name=end" json:"end,omitempty"`
}

func (m *Timespan) Reset()                    { *m = Timespan{} }
func (m *Timespan) String() string            { return proto.CompactTextString(m) }
func (*Timespan) ProtoMessage()               {}
func (*Timespan) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Timespan) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Timespan) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

type Point struct {
	Latitude  float32 `protobuf:"fixed32,1,opt,name=latitude" json:"latitude,omitempty"`
	Longitude float32 `protobuf:"fixed32,2,opt,name=longitude" json:"longitude,omitempty"`
}

func (m *Point) Reset()                    { *m = Point{} }
func (m *Point) String() string            { return proto.CompactTextString(m) }
func (*Point) ProtoMessage()               {}
func (*Point) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *Point) GetLatitude() float32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *Point) GetLongitude() float32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func init() {
	proto.RegisterType((*DataQueryResults)(nil), "dapper.DataQueryResults")
	proto.RegisterType((*DataQueryResult)(nil), "dapper.DataQueryResult")
	proto.RegisterType((*DataQueryRecord)(nil), "dapper.DataQueryRecord")
	proto.RegisterType((*KeyMetadataList)(nil), "dapper.KeyMetadataList")
	proto.RegisterType((*KeyMetadata)(nil), "dapper.KeyMetadata")
	proto.RegisterType((*Metadata)(nil), "dapper.Metadata")
	proto.RegisterType((*MetadataValue)(nil), "dapper.MetadataValue")
	proto.RegisterType((*Tag)(nil), "dapper.Tag")
	proto.RegisterType((*RelationSpan)(nil), "dapper.RelationSpan")
	proto.RegisterType((*Relation)(nil), "dapper.Relation")
	proto.RegisterType((*PointSpan)(nil), "dapper.PointSpan")
	proto.RegisterType((*KeyMetadataSnapshotList)(nil), "dapper.KeyMetadataSnapshotList")
	proto.RegisterType((*KeyMetadataSnapshot)(nil), "dapper.KeyMetadataSnapshot")
	proto.RegisterType((*DomainMetadataList)(nil), "dapper.DomainMetadataList")
	proto.RegisterType((*MetadataValuesList)(nil), "dapper.MetadataValuesList")
	proto.RegisterType((*Timespan)(nil), "dapper.Timespan")
	proto.RegisterType((*Point)(nil), "dapper.Point")
}

func init() { proto.RegisterFile("dapper.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 742 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x5b, 0x6f, 0xd4, 0x38,
	0x14, 0x56, 0x26, 0xd3, 0x34, 0x39, 0xd3, 0xaa, 0x5d, 0xf7, 0x96, 0x9d, 0xdd, 0x95, 0xda, 0x68,
	0x85, 0x5a, 0x89, 0x16, 0x5a, 0x1e, 0x40, 0x20, 0x04, 0x54, 0x33, 0x4f, 0x43, 0x25, 0x70, 0x47,
	0x20, 0x21, 0x24, 0xe4, 0x36, 0xee, 0x10, 0x35, 0x37, 0x25, 0x1e, 0xa4, 0xbc, 0xf3, 0xdf, 0x78,
	0xe3, 0xcf, 0xf0, 0x07, 0x90, 0xed, 0x38, 0x71, 0x66, 0x32, 0xbd, 0xf0, 0xe6, 0xe3, 0xf3, 0x1d,
	0xfb, 0xf3, 0xb9, 0x7c, 0x09, 0xac, 0xf8, 0x24, 0x4d, 0x69, 0x76, 0x94, 0x66, 0x09, 0x4b, 0x90,
	0x25, 0x2d, 0x6f, 0x08, 0xeb, 0x03, 0xc2, 0xc8, 0xfb, 0x29, 0xcd, 0x0a, 0x4c, 0xf3, 0x69, 0xc8,
	0x72, 0x74, 0x0c, 0xcb, 0x99, 0x5c, 0xba, 0xc6, 0xae, 0xb9, 0xdf, 0x3b, 0xd9, 0x39, 0x2a, 0x63,
	0x67, 0xa0, 0x58, 0xe1, 0xbc, 0xef, 0x06, 0xac, 0xcd, 0x38, 0xd1, 0x36, 0x58, 0x7e, 0x12, 0x91,
	0x20, 0x76, 0x8d, 0x5d, 0x63, 0xdf, 0xc1, 0xa5, 0x85, 0xd6, 0xc1, 0xbc, 0xa6, 0x85, 0xdb, 0x11,
	0x9b, 0x7c, 0x89, 0x36, 0x61, 0xe9, 0x2a, 0xa0, 0xa1, 0xef, 0x9a, 0x62, 0x4f, 0x1a, 0x92, 0xc6,
	0x65, 0x92, 0xf9, 0xb9, 0xdb, 0x5d, 0x48, 0x83, 0xfb, 0xb1, 0xc2, 0x79, 0xc3, 0x06, 0x0b, 0xbe,
	0x87, 0xfe, 0x05, 0x87, 0x05, 0x11, 0xcd, 0x19, 0x89, 0x52, 0x41, 0xc4, 0xc4, 0xf5, 0x06, 0xbf,
	0xf9, 0x1b, 0x09, 0xa7, 0xb4, 0x64, 0x23, 0x0d, 0xef, 0x14, 0xd6, 0x46, 0xb4, 0x38, 0xa3, 0x8c,
	0xf8, 0x84, 0x91, 0xb7, 0x41, 0xce, 0xd0, 0x23, 0xb0, 0xa3, 0xd2, 0x2e, 0x93, 0xb2, 0xa1, 0xd8,
	0x68, 0x50, 0x5c, 0x81, 0xbc, 0x1f, 0x26, 0xf4, 0x34, 0xcf, 0x3d, 0xb2, 0xf1, 0x3f, 0x74, 0xf3,
	0x94, 0xc4, 0xae, 0x29, 0xae, 0x59, 0x57, 0xd7, 0x8c, 0x39, 0xe9, 0x94, 0xc4, 0x58, 0x78, 0xd1,
	0x4b, 0x8d, 0x90, 0x4c, 0xcf, 0x5e, 0x0b, 0xa1, 0x23, 0xb5, 0x18, 0xc6, 0x2c, 0x2b, 0x6a, 0x7a,
	0xe8, 0x18, 0xba, 0x8c, 0x4c, 0x72, 0x77, 0x49, 0x84, 0xfe, 0xd7, 0x16, 0x3a, 0x26, 0x93, 0x5c,
	0x86, 0x09, 0x28, 0x3a, 0x04, 0x3b, 0x4c, 0x2e, 0x09, 0x0b, 0x92, 0xd8, 0xb5, 0x44, 0xd8, 0x5f,
	0x2a, 0xec, 0x5d, 0x12, 0xc4, 0xec, 0x9c, 0x93, 0xab, 0x20, 0xe8, 0x04, 0x9c, 0x8c, 0x86, 0x62,
	0x9d, 0xbb, 0xcb, 0x02, 0xbf, 0xa9, 0xf0, 0xb8, 0x74, 0x88, 0x90, 0x1a, 0xd6, 0x3f, 0x83, 0xd5,
	0x06, 0x61, 0x95, 0x1d, 0xa3, 0xce, 0xce, 0x03, 0xbd, 0x62, 0x5a, 0x7a, 0xaa, 0x12, 0x48, 0xf7,
	0xf3, 0xce, 0x33, 0xa3, 0x3f, 0x00, 0xa7, 0x7a, 0x44, 0xcb, 0x51, 0x7b, 0xcd, 0xa3, 0x7a, 0x55,
	0xa6, 0xc9, 0x44, 0x3b, 0xc5, 0x3b, 0x03, 0xbb, 0xaa, 0x22, 0x82, 0x6e, 0x4c, 0x22, 0x5a, 0x9e,
	0x22, 0xd6, 0xe8, 0x10, 0x2c, 0x01, 0xce, 0xdd, 0x8e, 0x78, 0xe5, 0xd6, 0x2c, 0xa5, 0x0f, 0xdc,
	0x8b, 0x4b, 0x90, 0x37, 0xaa, 0xdf, 0x28, 0x1c, 0x75, 0x0f, 0x1a, 0x5a, 0x0f, 0x56, 0x5d, 0x30,
	0xf3, 0xcc, 0x66, 0x17, 0x78, 0xaf, 0xc0, 0x1c, 0x93, 0x49, 0x2b, 0xad, 0xfa, 0x80, 0x1b, 0xda,
	0xc8, 0xbb, 0x80, 0x15, 0xbd, 0x18, 0xe8, 0x21, 0xd8, 0xaa, 0x1c, 0xe2, 0x34, 0x2d, 0x52, 0xe1,
	0x70, 0x85, 0xb8, 0x23, 0xc9, 0x31, 0xd8, 0x2a, 0x76, 0xe1, 0x18, 0xfc, 0x0d, 0xf6, 0x55, 0x96,
	0x44, 0x5f, 0xea, 0x59, 0x58, 0xe6, 0xf6, 0x88, 0x16, 0x68, 0x0b, 0x2c, 0x96, 0x08, 0x47, 0x29,
	0x0f, 0x2c, 0x19, 0xd1, 0xc2, 0xfb, 0x0c, 0x4e, 0xd5, 0x76, 0xe8, 0x40, 0xeb, 0x4d, 0x49, 0x7b,
	0xb5, 0xd1, 0x9b, 0x5a, 0x5f, 0xde, 0x8d, 0x33, 0x86, 0x1d, 0x6d, 0x16, 0xce, 0x63, 0x92, 0xe6,
	0x5f, 0x13, 0x26, 0xa4, 0xe0, 0xe9, 0x9c, 0x14, 0xfc, 0xd3, 0x32, 0x3e, 0x2a, 0x44, 0x93, 0x84,
	0x9f, 0x1d, 0xd8, 0x68, 0x41, 0xdc, 0x43, 0x1a, 0xb6, 0xc1, 0x8a, 0x92, 0x88, 0xc6, 0x4c, 0xa4,
	0xc2, 0xc4, 0xa5, 0x85, 0x86, 0x73, 0x62, 0x70, 0x70, 0x03, 0xa5, 0x85, 0xa2, 0x80, 0x34, 0x51,
	0x70, 0xca, 0xa9, 0x3f, 0x68, 0x4c, 0xfd, 0x8d, 0x99, 0xfd, 0x93, 0x89, 0x7f, 0x71, 0xfb, 0xc4,
	0xb7, 0x6a, 0xb4, 0x98, 0xcc, 0x5f, 0x06, 0xa0, 0x81, 0xc8, 0x55, 0x43, 0xab, 0x17, 0xe5, 0x13,
	0x41, 0xf7, 0x9a, 0x16, 0x72, 0x4c, 0x1d, 0x2c, 0xd6, 0x68, 0xa0, 0x65, 0x4e, 0x0a, 0xee, 0x7e,
	0xf5, 0x95, 0x99, 0x3b, 0xf9, 0xd6, 0xc4, 0x75, 0xeb, 0xc4, 0xf5, 0x3f, 0xde, 0xfe, 0xb2, 0xc7,
	0x4d, 0x01, 0xea, 0xb7, 0x0a, 0x47, 0xce, 0x6f, 0xd6, 0x5f, 0xfd, 0x1a, 0xd0, 0x3c, 0xa0, 0x55,
	0x02, 0xb6, 0x1b, 0xca, 0xe4, 0x54, 0x12, 0x74, 0x02, 0xb6, 0x6a, 0x77, 0x9e, 0xdd, 0x9c, 0x91,
	0x8c, 0x95, 0xdf, 0x46, 0x69, 0x70, 0xae, 0x34, 0xf6, 0x05, 0x2f, 0x13, 0xf3, 0xa5, 0xf7, 0x06,
	0x96, 0x44, 0xbd, 0x51, 0x1f, 0x6c, 0x5e, 0x3c, 0x36, 0xf5, 0xe5, 0x65, 0x1d, 0x5c, 0xd9, 0xfc,
	0x63, 0x1b, 0x26, 0xf1, 0x44, 0x3a, 0x3b, 0xc2, 0x59, 0x6f, 0x9c, 0xf6, 0x3e, 0x39, 0xf2, 0x81,
	0x61, 0x70, 0x71, 0x61, 0x89, 0xff, 0x90, 0x27, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x55, 0x4e,
	0x20, 0x5d, 0x97, 0x08, 0x00, 0x00,
}
